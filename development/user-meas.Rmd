---
title: "user measurements"
output: html_document
---

First, read in the packages.  

```{r packages, echo = F, warning = F, message = F}
library(tidyverse)
library(bulletxtrctr)
library(x3ptools)
library(gridExtra)
```

Read in the data, and extract Operator, Barrel, Bullet, and Land.  

```{r}
filenames <- list.files("/media/Sunny/CSAFE/User comparison scans/", pattern = "*.x3p", full.names = T, recursive = T)
user_meas <- data.frame(source = filenames)
user_meas <- user_meas %>% mutate(x3p = purrr::map(as.character(source), .f = function(filename){
  x3ptools::read_x3p(filename)
}))
head(user_meas)

user_meas <- user_meas %>% mutate(Round = purrr::map_chr(as.character(source), .f = function(source){
  strsplit(source, "/")[[1]][1]
}), 
Operator = purrr::map_chr(as.character(source), .f = function(source){
  strsplit(source, "/")[[1]][2]
}), 
source = factor(str_replace_all(source, ";", " -")),
Barrel = purrr::map_chr(as.character(source), .f = function(source){
  strsplit(source, " - ")[[1]][2]
}), 
Bullet = purrr::map_chr(as.character(source), .f = function(source){
  strsplit(source, " - ")[[1]][3]
}), 
Land = purrr::map_chr(as.character(source), .f = function(source){
  strsplit(source, " - ")[[1]][4]
}))

head(user_meas)
```

Extract ccdata from each of the x3p files, then convert them back to x3p files so we have the correct header.info...   

```{r, echo = F, warning = F, message = F}

#user_meas <- user_meas %>% mutate(
#  x3p = x3p %>% purrr::map(.f = function(x) x %>% 
#                             rotate_x3p(angle = -90) %>%
#                             y_flip_x3p())
#)
user_meas <- user_meas %>% mutate(ccdata = purrr::map(x3p, .f = function(x3p){
  x3ptools::x3p_to_df(x3p)
}))

user_meas <- user_meas %>% mutate(x3p = purrr::map(ccdata, .f = df_to_x3p))

#head(user_meas)
```


```{r, echo = F, warning = F, message = F}
#image_x3p(user_meas$x3p[[1]]) # doesn't work on the server
```



```{r, echo = F, warning = F, message = F}
user_crosscuts <- user_meas %>% mutate(
  crosscut = purrr::map_dbl(x3p, .f = x3p_crosscut_optimize)
)


x3p_ten_crosscut <- function(x3p, y = NULL, range = 1e-05){
  #x3pdat <- bulletxtrctr::check_x3p(x3p)
  x3p_df <- na.trim(x3p_to_df(x3p))
  ys <- unique(x3p_df$y)
  if (is.null(y))
    y <- median(ys)
  ind <- which.min(abs(y - ys))
  y_min <- ys[ind - 5]
  y_max <- ys[ind + 4]
  lower <- min(y_min, y_max)
  upper <- max(y_min, y_max)
  x3p_df_fix <- x3p_df[x3p_df$y >= lower & x3p_df$y <= upper,]
  return(na.omit(x3p_df_fix))
}
# now extract the crosscuts
user_crosscuts <- user_crosscuts %>% mutate(
  ccdata = purrr::map2(.x = x3p, .y = crosscut, 
                       .f = x3p_ten_crosscut)
)

user_c <- user_crosscuts %>% mutate(
  ccdata = purrr::map(ccdata, .f = function(ccdata){
    ccdata %>% group_by(x) %>% summarise(y = mean(y, na.rm = T), value = mean(value, na.rm = T))
  })
)


user_crosscuts <- user_crosscuts %>% mutate(
  grooves = ccdata %>% 
    purrr::map(.f = cc_locate_grooves, method = "lassobasic", 
               adjust = 10, return_plot = TRUE)
)



```





